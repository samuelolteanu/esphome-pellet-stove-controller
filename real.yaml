#todo
#dalasuri pe tur, retur si evacuare afara
#incercare da a schimba pin 18 auger swicth cu altceva de acolo care poate nu porneste in lymbo mode
#prevenire compilare pentru substituiri invalide ex max_water_temp: "49" < min_ignition_water_temp: "50"

substitutions:
  wait_for_preignition_time: "10min"  #time will pause dosing after mentioned time until temperature starts rising
  wait_for_ignition_time: "20min" #time, total time until ignition should occur
  ignition_delta_to_confirmed: "24" #float
  maximum_wait_for_stabilization_time: "10min" #time, failed ignition/stabilization at timeout
  minimum_run_of_stabilization_time: "1min" #time, keep stabilization running once met exhaust condition

  auger_percent_on_ignition: "15" #float
  auger_percent_on_stabilization: "35" #float
  auger_percent_on_normal_run: "45" #float, 45 max, 15 min
  auger_prefill_time: "30s" #time
  
  fan_percent_on_safety: "10"  # integer
  extinguished_temp: "50" #float
  minimum_extinguish_time: "5min" #time
  fully_ignited_temp: "100" #float 
  
  min_ignition_water_temp: "50" #float, water_temp_heating_pump_to_be_fully_on -20?
  water_temp_heating_pump_to_be_fully_on: "80" #float, 70 This is the stove water target temp, main thermostat.

  max_water_pressure: "2250" #hPa, 1bar=1000hPa
  min_water_pressure: "500" #float

  exhaust_absolute_max_temp: "200" #float 200
  max_water_temp: "90" #float, should be at least water_temp_heating_pump_to_be_fully_on + 10 so auger modulation would work as expected
 
  pellet_kwh_per_kg: "4.8" #float
  auger_fully_on_grams_per_second: "1.7336284202" #float

  min_ambient_temp: "5" #float
  max_ambient_temp: "7" #float
  min_exhaust_temp_pump_freeze_protection: "0" #float. pump will turn on periodically when less than this value
  pump_freeze_protection_min_run_time: "5min" # time, how much run time for every hour passed

debug:
  update_interval: 5s


psram:


esphome:
  name: esp32s2-8
  friendly_name: esp32s2-8
  on_boot:
   # - priority: 600
      then:
        - switch.turn_on: exhaust_fan_switch
        - delay: 5s
        - rtttl.play: 'scale_up:d=32,o=5,b=100:c,c#,d#,e,f#,g#,a#,b'
        - script.execute: booting_script
        - script.wait: booting_script
              

esp32:
  board: esp32-s2-saola-1
  framework:
    type: arduino

logger:
  level: debug
  logs:
    sensor: warn
    ads1115: warn
    dallas.sensor: error
    component: error
    max31855: warn
    climate: info
    number: warn
    display.tm1638: warn

api:
  encryption:
    key: !secret stove_api_key

ota:
  password: !secret stove_ota_password

wifi:
  reboot_timeout: 0s
  networks:
    - ssid: !secret wifi_ssid_5
      password: !secret wifi_password_5
      manual_ip:
        static_ip: 192.168.0.49
        gateway: 192.168.0.1
        subnet: 255.255.255.0
        dns1: 1.1.1.1
        dns2: 8.8.8.8 

mdns:

spi:
  - id: spi1
    miso_pin: 38
    clk_pin: 3

dallas:
  - pin: 37
    update_interval: 5s 
    

rtttl:
  output: rtttl_out
  id: my_rtttl


i2c:
  sda: 8
  scl: 9
  scan: True
  frequency: 50khz #200 unstable ads1115

sensor:
  - platform: uptime
    name: Uptime Sensor
    update_interval: 5s
          
 #- platform: rotary_encoder
 #  name: "Rotary Encoder"
 #  min_value: 7
 #  max_value: 80
 #  id: rotary
 #  resolution: 2
 #  pin_a:
 #      number: 12
 #      inverted: true
 #      mode:
 #        input: true
 #        pullup: true
 #  pin_b:
 #      number: 36
 #      inverted: true
 #      mode: 
 #        input: true
 #        pullup: true
 #  on_clockwise:
 #    - number.increment: water_temp_heating_pump_to_be_fully_on
 #  on_anticlockwise:
 #    - number.decrement:  water_temp_heating_pump_to_be_fully_on
          

  - platform: dallas
    address: 0x3c3ce104573d1c28
    name: "temperatura apa centrala dallas"
    accuracy_decimals: 1
   # resolution: 9
    id: stove_temp_dallas
    filters:
         - quantile:
              window_size: 10
              send_every: 10
              send_first_at: 5
              quantile: .9

  - platform: dallas
    address: 0x213ce1e3800a4828
    name: "Ambient Temp" #previously inlet dallas temp
    accuracy_decimals: 1
   # resolution: 9
    id: ambient_temp
    filters:
         - quantile:
              window_size: 10
              send_every: 10
              send_first_at: 5
              quantile: .9

      






  

  - platform: max31855
    spi_id: spi1
    name: "Evacuare max31855"
    cs_pin: 2
    update_interval: 1s
    id: exhaust_temp
    filters: 
       - skip_initial: 30 #max 59s or timeout error
       - max

  - platform: ads1115
  # conector 1 stanga sus sub ads
  #todo checked for unplugged, use change sensor filter
    multiplexer: 'A0_GND'
    gain: 4.096
    accuracy_decimals: 5
    name: "voltaj senzor presiune"
    id: a0_gnd
    update_interval: 5s
    

  - platform: ads1115
   # conector ntc port 1 dreapta sus sub expander
    multiplexer: 'A1_GND'
    gain: 4.096
    accuracy_decimals: 5
    name: "ntc_temp_1_source_voltage"
    id: a1_gnd_ntc_temp_1
    update_interval: 0.01s # 0.001
    filters:
      - median:
            window_size: 250 #5000
            send_every: 100  #5000

  - platform: ads1115
  # conector ntc port 2 dreapta sus sub expander
    multiplexer: 'A2_GND'
    gain: 4.096
    accuracy_decimals: 2
    name: "ntc_temp_2_source_voltage"
    id: a2_gnd_ntc_temp_2
    update_interval: 5s

  - platform: ads1115
  # conector ntc port 2 dreapta sus sub expander
    multiplexer: 'A3_GND'
    gain: 4.096
    accuracy_decimals: 2
    name: "A3_GND"
    update_interval: 5s


########### end hardware sensors ###########

  - platform: template
  # conector 1 stanga sus sub ads
    name: "Presiune Apa"
    id: water_pressure
    state_class: measurement
    unit_of_measurement: "hPa"
    accuracy_decimals: 0
    update_interval: 5s
    lambda: |-
      return id(a0_gnd).state;
    filters:
      - lambda: return 1.410168458 * x - 0.7025459258;
      - multiply: 1000
      # 1800  hpa  ->  1.8931
      # 1230  hpa  ->  1.62900   v
      
    on_value_range:
      - above: ${max_water_pressure}
        then:
          - lambda: id(water_pressure_good).publish_state(false);
          - lambda: id(boot_completed).publish_state(false);
          - switch.turn_on: heating_pump_switch
          - text_sensor.template.publish:
                                  id: unexpected
                                  state: "Max Water Pressure Reached, extinuishing.."
          - button.press: start_extinguishing_virtual_button
          - script.wait: normal_extinguish_script
          - delay: 5s
          - text_sensor.template.publish:
                                  id: stove_status
                                  state: "Abnormal water pressure (too high)"

      - below: ${min_water_pressure}
        then:
          - lambda: id(water_pressure_good).publish_state(false);
          - lambda: id(boot_completed).publish_state(false);
          - switch.turn_on: heating_pump_switch
          - text_sensor.template.publish:
                                  id: unexpected
                                  state: "Min Water Pressure Reached, extinuishing.."
          - button.press: start_extinguishing_virtual_button
          - script.wait: normal_extinguish_script
          - delay: 5s
          - text_sensor.template.publish:
                                  id: stove_status
                                  state: "Abnormal water pressure (too low)"
      

  - platform: template
    name: "auger_dozer_modulation"
    id: auger_modulation_status
    state_class: measurement
    unit_of_measurement: "%"
    accuracy_decimals: 0
    update_interval: 1s

  - platform: template
    name: "temperatura apa centrala"
    id: stove_water_temp
    state_class: measurement
    unit_of_measurement: "°C"
    accuracy_decimals: 2
    update_interval: 1s
    lambda: |-
      return id(a1_gnd_ntc_temp_1).state;
    filters:
        - calibrate_linear:
           method: least_squares
           datapoints:
                - 1.6195     ->     54.4
                - 1.1771     ->     82.0
                - 1.3041     ->     66.7
                - 2.3306     ->     21.5
                - 2.0899     ->     36.0
    on_value_range:
      - above: ${max_water_temp}
        then:
          - lambda: id(boot_completed).publish_state(false);
          - switch.turn_on: heating_pump_switch
          - button.press: start_extinguishing_virtual_button
          - script.wait: normal_extinguish_script
          - text_sensor.template.publish:
                                  id: unexpected
                                  state: "Max Water Temperature Reached, extinuishing"
          - delay: 5s
          #todo maintain temp for domestic water boiler, wait until temp goes back to an acceptable level and then turn off pump
          - text_sensor.template.publish:
                                  id: stove_status
                                  state: "Max Water Temperature Reached" #idle?



      


  - platform: template
    name: "temperatura ntc2"
    id: ntc_ch2_temp
    state_class: measurement
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    update_interval: 5s
    lambda: |-
      return id(a2_gnd_ntc_temp_2).state;
    filters:
        - calibrate_linear:
           method: least_squares
           datapoints:
                - 1.6195     ->     54.4
                - 1.1771     ->     82.0
                - 1.3041     ->     66.7
                - 2.3306     ->     21.5
                - 2.0899     ->     36.0

  - platform: template
    accuracy_decimals: 7
    update_interval: 1s
    id: auger_current_feed
    name: auger_current_feed
    unit_of_measurement: "Kg/H"
    lambda: |-
          bool ignition = id(ignition_auger_enabler).state;
          bool stabilization = id(stabilization_auger_enabler).state;
          bool normal_run = id(normal_run_auger_enabler).state;
          if (ignition) {
           return id(auger_percent_on_ignition).state;
          }
          else if(stabilization) {
           return id(auger_percent_on_stabilization).state; 
          }
          else if(normal_run) {
            if (isnanf(id(auger_modulation_status).state)) {
              return id(auger_percent_on_normal_run).state;
            } 
            else {
              return id(auger_modulation_status).state;
            }
          }
          else { 
            return 0;
          }      
    filters:
         #time s        percent on        quantity            medium_lenght
         #120            45                    85   g            2.5cm?
         #120            15                    32   g            idem
         #120            30                    59   
         #120            20                    49   
         #120            10                    17   
         #120            50                    112  
         #120            40                    82   
         #120            90                    190  
         #120            5                     12   
         #120            75                    153           
         #
         # 
         #time s        percent on        quantity/120                            medium_lenght
         #1            45                    0.7083333333333333   g/s              2.5cm?
         #1            15                    0.2666666666666667   g/s                idem
         #1            30                    0.4916666666666667   
         #1            20                    0.4083333333333333   
         #1            10                    0.1416666666666667   
         #1            50                    0.9333333333333333  
         #1            40                    0.6833333333333333   
         #1            90                    1.583333333333333  
         #1            5                     0.1   
         #1            75                    1.275
         #   liniar regression:
         #                  grams/s = 0.0173300283 * percent_on + 0.0006255902
      - lambda:  |-
              float lambzda = 0.0173300283 * x + 0.0006255902;
              bool prefilling = id(auger_status).state == "Prefilling...";
              float prefill_rate = ${auger_fully_on_grams_per_second};
              if (prefilling) {
                return prefill_rate;
              }
              else if (lambzda < 0.0024) {
              return 0;
              }
              else {
                return lambzda;
              }
      - multiply: 3.6 # g/s to kg/h

      
  - platform: template
    accuracy_decimals: 0
    update_interval: 1s
    id: power
    name: "Putere Centrala"
    unit_of_measurement: "W"
    lambda: return id(auger_current_feed).state * 1000 * ${pellet_kwh_per_kg} * 0.9;  # 10% estimated loss
          
  - platform: integration
    id: total_consumption
    name: "Consum Peleti"
    state_class: total_increasing
    time_unit: h
    unit_of_measurement: kg
    sensor: auger_current_feed
    restore: true
    accuracy_decimals: 4
    integration_method: left

ads1115:
  - address: 0x48
    continuous_mode: true
  

switch:

  - platform: gpio
    name: "auger_switch"
    # conector 1 stanga jos
    id: auger_switch
    pin: 18 
    restore_mode: always_off
    on_turn_on:
      then:
        - output.turn_on: TM1638Led2
    on_turn_off:
      then:
        - output.turn_off: TM1638Led2
    

  - platform: gpio
    # conector stanga lateral colt, un singur pin
    name: "Igniter Switch"
    id: igniter_switch
    pin: 14
    inverted: False
    restore_mode: always_off
    on_turn_on:
      then:
        - output.turn_on: TM1638Led3
    on_turn_off:
      then:
        - output.turn_off: TM1638Led3

  - platform: gpio
    # conector 2 stanga jos
    name: "Exhaust Fan Switch"
    id: exhaust_fan_switch
    pin: 7
    inverted: False
    on_turn_on:
      then:
        - output.turn_on: TM1638Led8
    on_turn_off:
      then:
        - output.turn_off: TM1638Led8
    
  - platform: gpio
  # conector 3 stanga jos
    name: "Heating Pump Switch"
    id: heating_pump_switch
    pin: 6
    inverted: True
    restore_mode: always_on
    on_turn_on:
      then:
        - output.turn_on: TM1638Led4
    on_turn_off:
      then:
        - output.turn_off: TM1638Led4


  - platform: gpio
  # conector 4 stanga jos
    name: "DW Pump Switch"
    id: dw_pump_switch
    pin: 15
    inverted: False
    on_turn_on:
      then:
        - output.turn_on: TM1638Led5
    on_turn_off:
      then:
        - output.turn_off: TM1638Led5

########### end hardware switches  ###########

  - platform: template
    name: "fan_sigma_delta_enabler"
    id: fan_sigma_delta_enabler
    restore_mode: ALWAYS_OFF
    optimistic: True     

  - platform: template
    name: "Gratar plin de la aprindere"
    id: prefilled
    optimistic: true
    restore_mode: restore_default_off

  - platform: template
    name: "auger_dozer_ignition"
    id: ignition_auger_enabler
    optimistic: true
    on_turn_off:
      - switch.turn_off: auger_switch

  - platform: template
    name: "auger_dozer_stabilization"
    id: stabilization_auger_enabler
    optimistic: true
    on_turn_off:
      - switch.turn_off: auger_switch

  - platform: template
    name: "auger_dozer_normal_run"
    id: normal_run_auger_enabler
    optimistic: true
    on_turn_off:
      - switch.turn_off: auger_switch

  - platform: template
    name: "Completely extinguished"
    id: extinguish_completed
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "override_extinguish"
    id: override_extinguish
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

#  - platform: template
#    name: "auger_periodic_feed_while_ignition"
#    id: auger_periodic_feed_while_ignition
#    optimistic: true
#    restore_mode: restore_default_on


  - platform: template
    name: "Heating Pump Slow PWM Enabler"
    id: heating_pump_slow_pwm_enabler
    optimistic: true
    restore_mode: ALWAYS_ON
    on_turn_off:
      then:
        switch.turn_on: heating_pump_switch
    on_turn_on:
      then:
        switch.turn_off: heating_pump_switch #careful
    


#  - platform: template
#    name: "Exhaust fan switch modulated"
#    id: exhaust_fan_switch_modulated
#    optimistic: true

#font:
#  # gfonts://family[@weight]
#  - file: "gfonts://Roboto"
#    id: roboto
#    size: 11

#display:
#  - platform: ssd1306_i2c
#    model: "SSD1306 128x64"
#    address: 0x3C
#    contrast: 90%
#    rotation: 180
#    update_interval: 30s
#    lambda: |-
#       it.printf(0, 0, id(roboto), "%s", id(stove_status).state.c_str());
#       it.printf(0, 15, id(roboto), "Water:%.2f,Target:%.0f°C", id(stove_water_temp).state, id(water_temp_heating_pump_to_be_fully_on).state);
#       it.printf(0, 30, id(roboto), "Modulation: %.0f%%/10S", id(auger_modulation_status).state);
#       it.printf(0, 45, id(roboto), "Exhaust:%.0f°CAmbient:%.1f°C", id(exhaust_temp).state, id(ambient_temp).state);


display:
  platform: tm1638
  stb_pin: 36
  clk_pin: 13
  dio_pin: 12
  intensity: 4
  update_interval: 2.5s
  lambda: |-
      static bool flash = true;
      if (flash) {
          bool home = id(climate_controller).preset == climate::CLIMATE_PRESET_HOME;
          bool away = id(climate_controller).preset == climate::CLIMATE_PRESET_AWAY;
          bool offed = id(climate_controller).mode == climate::CLIMATE_MODE_OFF;
          bool heat = id(climate_controller).mode == climate::CLIMATE_MODE_HEAT;
          if (home && heat) {
            it.printf(0, "         ");
            it.printf(0, "%.1f'C ON", id(stove_water_temp).state);
          } 
          else if (away && heat) {
            it.printf(0, "         ");
            it.printf(0, "%.1f' FRZ", id(stove_water_temp).state);
          }
          else if (offed) {
            it.printf(0, "          ");
            it.printf(0, "%.1f' OFF", id(stove_water_temp).state);
          }
          else {
          it.printf(0, "         ");
          it.printf(0, "%.1f'C   ", id(stove_water_temp).state);
          }
      }   
      else {
        it.printf(0, "        ");
        it.printf(0, "%s", id(stove_status).state.c_str());
      }
      flash = !flash;
       
output:         
  - platform: tm1638
    id: TM1638Led1
    led: 0
  - platform: tm1638
    id: TM1638Led2
    led: 1
  - platform: tm1638
    id: TM1638Led3
    led: 2
  - platform: tm1638
    id: TM1638Led4
    led: 3
  - platform: tm1638
    id: TM1638Led5
    led: 4
  - platform: tm1638
    id: TM1638Led6
    led: 5
  - platform: tm1638
    id: TM1638Led7
    led: 6
  - platform: tm1638
    id: TM1638Led8
    led: 7
  - platform: ledc
    id: rtttl_out
    pin: 35
 ####### end hardware ###########

  - platform: slow_pwm
    id: heating_pump_slow_pwm
    period: 100s
    zero_means_zero: true
    min_power: 0
    max_power: 1
    turn_on_action:
      if:
        condition:
          - switch.is_on: heating_pump_slow_pwm_enabler
          - binary_sensor.is_on: boot_completed
        then:
          - switch.turn_on: heating_pump_switch
          - text_sensor.template.publish:
                            id: heating_pump_status
                            state: "ON by slow_pwm"

    turn_off_action:
      if:
        condition:
          - switch.is_on: heating_pump_slow_pwm_enabler
          - binary_sensor.is_on: boot_completed
        then:
          - switch.turn_off: heating_pump_switch
          - text_sensor.template.publish:
                            id: heating_pump_status
                            state: "Off by slow_pwm"

  - platform: sigma_delta_output
    update_interval: 0.05s
    id: sd_fan_output
    zero_means_zero: true
    min_power: 0
    max_power: 1
    turn_on_action:
      then:
        if: 
          condition:
            - switch.is_on: fan_sigma_delta_enabler
          then:
             - switch.turn_on: exhaust_fan_switch
    turn_off_action:
      then:
        if: 
          condition:
            - switch.is_on: fan_sigma_delta_enabler
          then:
             - switch.turn_off: exhaust_fan_switch


#  - platform: slow_pwm  #a dat restart o data // apoi nu a mai dat toata noaptea dupa ota
#    id: auger_slow_pwm
#    period: 10s
#    zero_means_zero: false
#    min_power: 15%
#    max_power: 40%
#    turn_on_action:
#      if:
#          condition:
#            - text_sensor.state:
#                id: stove_status
#                state: 'Normal'
#            - switch.is_off: normal_run_auger_enabler
#            - lambda: 'return id(stove_water_temp).state >= id(water_temp_heating_pump_to_be_fully_on).state;'
#
#          then:
#            - switch.turn_on: auger_switch
        
            
#    turn_off_action:
#      if:
#          condition:
#            - text_sensor.state:
#                id: stove_status
#                state: 'Normal'
#            - switch.is_off: normal_run_auger_enabler
#            - lambda: 'return id(stove_water_temp).state >= id(water_temp_heating_pump_to_be_fully_on).state;'
#          then:
#            - switch.turn_off: auger_switch

#  - platform: template   #reboot posibil loop numar blocat pe minim
#    id: output_for_pid
#    type: float
#    write_action:
#      - number.set:
#            id: number_for_testing_being_changed_by_output
#            value: !lambda 'return state;'

binary_sensor:
  - platform: tm1638
    name: "Button 1"
    id: TM1638Button1
    key: 0
    filters:
      - delayed_on: 2.5s
    on_press:
     then:
      - climate.control:
            id: climate_controller
            mode: "HEAT"
            preset: "HOME"
      - rtttl.play: 'two_short:d=4,o=5,b=100:16e6,16e6'


  - platform: tm1638
    name: "Button 2"
    id: TM1638Button2
    key: 1
    filters:
      - delayed_on: 2.5s
    on_press:
     then:
      - button.press: start_extinguishing_virtual_button
      - climate.control:
            id: climate_controller
            mode: "HEAT"
            preset: "AWAY"
 

  - platform: tm1638
    name: "Button 3"
    id: TM1638Button3
    key: 2
    filters:
      - delayed_on: 2.5s
    on_press:
     then:
      - climate.control:
            id: climate_controller
            mode: "OFF"
      - rtttl.play: 'scale_inverted:d=32,o=5,b=100:b,a#,g#,f#,e,d#,c,c#'


  - platform: tm1638
    name: "Button 7"
    id: TM1638Button7
    key: 6
    filters:
      - delayed_on: 50ms
    on_double_click :
     then:   
      - switch.turn_on: extinguish_completed
      - delay: 1s
      - button.press: restartus

  - platform: tm1638
    name: "Button 8"
    id: TM1638Button8
    key: 7
    filters:
      - delayed_on: 50ms
    on_double_click :
     then:   
      - button.press: restartus
            


       
  - platform: gpio
    name: "Air negative pressure"
    id: air_pressure_binary_sensor
    pin:
      number: 1
      mode:
        input: true
        pullup: true
    on_press:
      then:
        - output.turn_on: TM1638Led6
    on_release:
        - output.turn_off: TM1638Led6
        #maybe won't work well.
        - if:
           condition:
            for:
              time: 30s
              condition:
                 - switch.is_on: exhaust_fan_switch
           then:
            - button.press: start_extinguishing_virtual_button
            - text_sensor.template.publish:
                            id: unexpected
                            state: "Air pressure sensor failure during run" 

  # ultimul conector colt jos dreapta 
  - platform: gpio
    name: "Termostat Extern"
    id: gpio_in_2
    pin:
      number: 10
      mode:
        input: true
        pullup: true
      inverted: true
  # penultimul conector colt jos dreapta 
  - platform: gpio
    name: "Buton Fizic"
    id: gpio_in_3
    pin:
      number: 11
      mode:
        input: true
        pullup: true
      inverted: true

########### end hardware binary sensors ###########
  
  - platform: template
    id: "boot_completed"
    name: "boot_completed"
    internal: False



  - platform: template
    id: "water_pressure_good"
    name: "water_pressure_good"
    internal: False
  - platform: template
    name: "is_running_booting_script"
    id: is_running_booting_script
    internal: False
    lambda: |-
       if (id(booting_script).is_running()) {
           return true;
       } else {
        return false;
       }


  - platform: template
    name: "is_running_air_pressure_binary_sensor_checkup"
    id: is_running_air_pressure_binary_sensor_checkup
    internal: False
    lambda: |-
       if (id(air_pressure_binary_sensor_checkup).is_running()) {
           return true;
       } else {
        return false;
       }

  - platform: template
    name: "is_running_ignition_script"
    id: is_running_ignition_script
    internal: False
    lambda: |-
       if (id(ignition_script).is_running()) {
           return true;
       } else {
        return false;
       }

  - platform: template
    name: "is_running_normal_extinguish_script"
    id: is_running_normal_extinguish_script
    internal: False
    lambda: |-
       if (id(normal_extinguish_script).is_running()) {
           return true;
       } else {
        return false;
       }

  - platform: template
    name: "is_running_stabilization_script"
    id: is_running_stabilization_script
    internal: False
    lambda: |-
       if (id(stabilization_script).is_running()) {
           return true;
       } else {
        return false;
       }

  - platform: template
    name: "is_running_normal_run_script"
    id: is_running_normal_run_script
    internal: False
    lambda: |-
       if (id(normal_run_script).is_running()) {
           return true;
       } else {
        return false;
       }


  - platform: template
    name: "is_running_monitoring_unexpected_script_for_normal_operation"
    internal: False
    lambda: |-
       if (id(monitoring_unexpected_script_for_normal_operation).is_running()) {
           return true;
       } else {
        return false;
       }

  - platform: template
    name: "is_nan_exhaust_temp"
    id: "is_nan_exhaust_temp"
    internal: False
    lambda: |-
       if(isnanf(id(exhaust_temp).state)) {
           return true;
       } else {
        return false;
       }



  

web_server:
  local: true

button:
  - platform: safe_mode
    id: safe_moude
    name: safe_mode

  - platform: template
    name: Resetare Consum Peleti
    on_press:
       then:
        - sensor.integration.reset: total_consumption

  - platform: template
    name: Test fab percent
    on_press:
       then:
        - switch.turn_on: fan_sigma_delta_enabler
        - number.set:
             id: fan_sigma_delta_modulation
             value: ${fan_percent_on_safety}
         

  - platform: template
    name: "Start presostat checkup script"
    on_press:
      - script.execute: air_pressure_binary_sensor_checkup


  - platform: template                
    name: "Start ignition"
    id: start_ignition_virtual_button
    on_press:
      - rtttl.play: 'two_short:d=4,o=5,b=100:16e6,16e6'
      - script.wait: booting_script
      - if:
          condition:
            - lambda: 'return id(water_pressure).state > ${min_water_pressure};'
            - lambda: 'return id(water_pressure).state < ${max_water_pressure}*0.9;'
          then:
            - lambda: id(water_pressure_good).publish_state(true);
            - rtttl.play: 'two_short:d=4,o=5,b=100:16e6,16e6'
            - if:
               condition:
                   - binary_sensor.is_off: is_running_ignition_script
                   - binary_sensor.is_off: is_running_normal_run_script
                   - binary_sensor.is_off: is_running_stabilization_script
               then:
                   - wait_until:
                      - binary_sensor.is_on: boot_completed #
                   - if: 
                      condition:
                        or:
                          - switch.is_on: extinguish_completed
                          - switch.is_on: override_extinguish
                      then:
                       - text_sensor.template.publish:
                                    id: stove_status
                                    state: "Prechecking..."
                       - switch.turn_on: exhaust_fan_switch
                       - delay: 30s #needs fan on for the next step to be valid
                       - if:
                          condition:
                           - lambda: 'return id(stove_water_temp).state < ${min_ignition_water_temp};'
                           - lambda: 'return id(exhaust_temp).state < 80;'  #todo hot ignition/flame recovery ##low priority
                          then:
                            - script.stop: normal_extinguish_script
                            - script.execute: ignition_script
                            
                          else:
                            - switch.turn_off: heating_pump_slow_pwm_enabler
                            - switch.turn_on: heating_pump_switch
                            - text_sensor.template.publish:
                                    id: stove_status
                                    state: "Wait for water temp to get lower than ${min_ignition_water_temp} and exhaust lower than 80"
                            - wait_until:
                                condition:
                                  and:
                                   - lambda: 'return id(stove_water_temp).state < ${min_ignition_water_temp};'
                                   - lambda: 'return id(exhaust_temp).state < 80;'
                            - switch.turn_on: heating_pump_slow_pwm_enabler       
                            - script.execute: ignition_script
                            #- switch.turn_off: heating_pump_switch
                            
                      else:
                       - script.execute: normal_extinguish_script
                       - text_sensor.template.publish:
                                    id: stove_status
                                    state: "Will start after extinguishing first"    
                       - script.wait: normal_extinguish_script
                       - script.execute: ignition_script
               else:
                 - rtttl.play: 'two_short:d=4,o=5,b=100:16e6,16e6'
                 - rtttl.play: 'two_short:d=4,o=5,b=100:16e6,16e6'
                # - script.execute: normal_extinguish_script
                 - text_sensor.template.publish:
                                     id: unexpected
                                     state: "Attempted ignition in running mode"
          else:
              - rtttl.play: long:d=1,o=5,b=100:e6
              - lambda: id(water_pressure_good).publish_state(false);
              - lambda: id(boot_completed).publish_state(false);
              - switch.turn_on: heating_pump_switch
              - text_sensor.template.publish:
                                       id: stove_status
                                       state: "Water pressure error - won't proceed"  
   
  - platform: template
    name: "Start extinguishing"
    id: start_extinguishing_virtual_button
    on_press:
      - script.execute: normal_extinguish_script
      - if:
          condition:
              - binary_sensor.is_on: is_running_ignition_script
          then:
              - text_sensor.template.publish:
                                       id: unexpected
                                       state: "Will extinguishing after ignition"
              - rtttl.play: long:d=1,o=5,b=100:e6
          else:
              - rtttl.play: 'two_short:d=4,o=5,b=100:16e6,16e6'
          
          

      
     # - switch.turn_on: heating_pump_switch
      

  - platform: restart
    name: "ESP Restart"
    id: restartus

  - platform: template
    name: "test remember exhaust temp"
    on_press:
      - number.set:
                  id: stove_exhaust_temp_before_ignition
                  value: !lambda "return id(exhaust_temp).state;"
  


text_sensor:
  - platform: template
    name: "Unexpected behaviour"
    id: unexpected
    update_interval: 1s

  - platform: template
    name: "Stove General Status"
    id: stove_status
    update_interval: 1s

  - platform: template
    name: "Air Binary Sensor Status"
    id: air_sensor_checking_ups
    update_interval: 1s

  - platform: template
    name: "Exhaust Fan Status"
    id: exhaust_fan_status
    update_interval: 1s

  - platform: template
    name: "Auger Status"
    id: auger_status
    update_interval: 1s

  - platform: template
    name: "Heating Pump Status"
    id: heating_pump_status
    update_interval: 1s

number:
 ###### begin dummy sensors here####
 #- platform: template
 #  internal: true
 #  name: "dummy_water_pressure"
 #  id: dummy_water_pressure
 #  unit_of_measurement: "hPa"
 #  min_value: -5
 #  max_value: 9000
 #  mode: box
 #  step: 1
 #  optimistic: true
 #  restore_value: true
 #  on_value_range:
 #    - above: 2500 #todo substiturions
 #      then:
 #        - lambda: id(water_pressure_good).publish_state(false);
 #        - text_sensor.template.publish:
 #                                id: unexpected
 #                                state: "Max Water Pressure Reached, extinuishing.."
 #        - button.press: start_extinguishing_virtual_button
 #        - script.wait: normal_extinguish_script
 #        - delay: 5s
 #        - text_sensor.template.publish:
 #                                id: stove_status
 #                                state: "Abnormal water pressure (too high)"

 #    - below: 500 #todo substiturions
 #      then:
 #        - lambda: id(water_pressure_good).publish_state(false);
 #        - text_sensor.template.publish:
 #                                id: unexpected
 #                                state: "Min Water Pressure Reached, extinuishing.."
 #        - button.press: start_extinguishing_virtual_button
 #        - script.wait: normal_extinguish_script
 #        - delay: 5s
 #        - text_sensor.template.publish:
 #                                id: stove_status
 #                                state: "Abnormal water pressure (too low)"
 #
 #- platform: template
 #  internal: true
 #  name: "dummy_ambient_temp"
 #  id: dummy_ambient_temp
 #  unit_of_measurement: "°C"
 #  min_value: -5
 #  max_value: 500
 #  mode: box
 #  step: 0.5
 #  optimistic: true
 #  restore_value: true

 #- platform: template
 #  internal: true
 #  name: "dummy_exhaust_temp"
 #  id: dummy_exhaust_temp
 #  unit_of_measurement: "°C"
 #  min_value: -5
 #  max_value: 500
 #  mode: box
 #  step: 1
 #  optimistic: true
 #  restore_value: true

 #  #filters: ##flters don't work here, wpuld work with intermediary template sensor if needed
 #  #   - skip_initial: 30 #max 60s or timeout error
 #  #   - max

 #- platform: template
 #  name: "dummy_stove_water_temp"
 #  internal: true
 #  id: dummy_stove_water_temp
 #  unit_of_measurement: "°C"
 #  min_value: -5
 #  max_value: 500
 #  mode: box
 #  step: 0.01
 #  optimistic: true
 #  restore_value: true
 #  on_value_range:
 #  #  - above: ${water_temp_heating_pump_to_be_fully_on}
 #  #    below: ${max_water_temp}
 #  #    then:
 #  #      - switch.turn_off: normal_run_auger_enabler # for pwm to kick in

 #    - above: ${max_water_temp}
 #      then:
 #        - button.press: start_extinguishing_virtual_button
 #        - script.wait: normal_extinguish_script
 #        - text_sensor.template.publish:
 #                                id: unexpected
 #                                state: "Maybe not needed...Max Water Temperature Reached, extinuishing for now"
 #        - delay: 5s
 #        #todo maintain temp for domestic water boiler, wait until temp goes back to an acceptable level and then turn off pump
 #        - text_sensor.template.publish:
 #                                id: stove_status
 #                                state: "Max Water Temperature Reached" #idle?
                                  
#  - platform: template
#    name: "number_for_testing_being_changed_by_output"
#    id: number_for_testing_being_changed_by_output
#    min_value: 0
#    max_value: 1
#    step: 0.01
#    optimistic: true
#
#  - platform: template
#    name: "number_for_testing_to_change_the_output"
#    id: number_for_testing_to_change_the_output
#    min_value: 0
#    max_value: 1
#    step: 0.01
#    optimistic: true
#    on_value:
#      then:
#        - output.set_level:
#            id: output_for_pid
#            level: !lambda 'return x;'
#  - platform: template
#    name: "test_this_number"
#    id: test_this_number
#    min_value: 0
#    max_value: 1000
#    mode: box
#    step: 0.1
#    optimistic: true
#    initial_value: 0.1
# end dummy sensors

  - platform: template
    name: "fan_sigma_delta_modulation"
    id: fan_sigma_delta_modulation
    min_value: 10
    max_value: 100
    step: 1
    optimistic: true
    restore_value: true
    initial_value: 100
    mode: box
    on_value:
      then:
        - output.set_level:
            id: sd_fan_output
            level: !lambda 'return x/100;'

  - platform: template
    name: "Minimum Ambient Temp"
    id: min_ambient_temp
    min_value: 0
    max_value: 30
    mode: box
    step: 0.1
    optimistic: true
    restore_value: true
    initial_value: ${min_ambient_temp}

  - platform: template
    name: "Maximum Ambient Temp"
    id: max_ambient_temp
    min_value: 0
    max_value: 30
    mode: box
    step: 0.1
    optimistic: true
    restore_value: true
    initial_value: ${max_ambient_temp}

  - platform: template
    name: "stove exhaust temp before ignition"
    id: stove_exhaust_temp_before_ignition
    min_value: -5
    max_value: 500
    mode: box
    step: 1
    optimistic: true

  - platform: template
    name: "auger_percent_on_ignition"
    id: auger_percent_on_ignition
    min_value: 0
    max_value: 50
    mode: box
    step: 1
    optimistic: true
    initial_value: ${auger_percent_on_ignition}

  - platform: template
    name: "auger_percent_on_stabilization"
    id: auger_percent_on_stabilization
    min_value: 15
    max_value: 50
    mode: box
    step: 1
    optimistic: true
    initial_value: ${auger_percent_on_stabilization}

  - platform: template
    name: "auger_percent_on_normal_run"
    id: auger_percent_on_normal_run
    min_value: 15
    max_value: 50
    mode: box
    step: 1
    optimistic: true
    initial_value: ${auger_percent_on_normal_run}

  - platform: template
    name: "water_temp_heating_pump_to_be_fully_on"
    id: water_temp_heating_pump_to_be_fully_on
    min_value: 15
    max_value: 80
    mode: box
    step: 1
    optimistic: true
    restore_value: true
    initial_value: ${water_temp_heating_pump_to_be_fully_on}

#  - platform: template
#    name: "auger_pwm_set_output"
#    id: auger_pwm_set_output
#    min_value: 0
#    max_value: 100
#    mode: box
#    step: 1
#    optimistic: true
#    initial_value: 0
#    on_value:
#      then:
#        - output.set_level:
#            id: auger_slow_pwm
#            level: !lambda 'return 0.01 * x;'

  - platform: template
    name: "Heating Pump Set PWM Percent Output"
    id: heating_pump_pwm_set_output_percent
    min_value: 0
    max_value: 100
    mode: box
    step: 1
    optimistic: true
    initial_value: 75 #100 won't stop pump after boot?
    on_value:
      then:
        - output.set_level:
            id: heating_pump_slow_pwm
            level: !lambda 'return 0.01 * x;'
        


#  - platform: template
#    name: "fan_percent"
#    id: fan_percent
#    min_value: 0
#    max_value: 100
#    step: 1
#    optimistic: true
#    initial_value: ${fan_percent}

interval:
    - interval: 1h
      id: self_start_controller
      then:
        - if:
            condition:
              - lambda: 'return id(heating_pump_pwm_set_output_percent).state == 0;'
              - lambda: 'return id(exhaust_temp).state < ${min_exhaust_temp_pump_freeze_protection};'
            then:
                - text_sensor.template.publish:
                            id: heating_pump_status
                            state: "ON by freeze protection"
                - switch.turn_off: heating_pump_slow_pwm_enabler #pump turns on here
                - wait_until:
                    condition:
                      - lambda: 'return id(exhaust_temp).state > (${min_exhaust_temp_pump_freeze_protection}+5);'
                    timeout: ${pump_freeze_protection_min_run_time}
                - switch.turn_on: heating_pump_slow_pwm_enabler
                - text_sensor.template.publish:
                      id: heating_pump_status
                      state: "Previously ON by freeze protection"


                    





    #- interval: 10s
    #  id: self_start_controller
    #  then:
    #    - if:
    #        condition:
    #            - switch.is_on: maintain_ambient
    #            - binary_sensor.is_on: boot_completed
    #            
    #        then:
    #          - if: 
    #              condition:
    #                - binary_sensor.is_off: is_runnning_self_started_script
    #                - lambda: 'return id(ambient_temp).state <= id(min_ambient_temp).state;'
    #                - text_sensor.state:
    #                      id: stove_status
    #                      state: 'Ready for ignition'
    #              then:
    #                - homeassistant.service:
    #                    service: notify.samuelis_runnning_self_started_script
    #                    data:
    #                      title: Porneste!
    #                    data_template:
    #                      message: "{{my_variable|round(1)}}°C, a pornit centrala singura!"
    #                    variables:
    #                         my_variable: |-
    #                            return id(ambient_temp).state;
    #                - script.execute: self_started_script
    #              else:
    #                if:
    #                  condition:
    #                    - lambda: 'return id(ambient_temp).state >= id(max_ambient_temp).state;'
    #                    - binary_sensor.is_on: is_runnning_self_started_script
    #                  then:
    #                    - homeassistant.service:
    #                        service: notify.samuel
    #                        data:
    #                          title: Se opreste!
    #                        data_template:
    #                          message: "{{my_variable|round(1)}}°C, s-a oprit centrala!"
    #                        variables:
    #                             my_variable: |-
    #                                return round(id(ambient_temp).state);
    #                    - script.stop: self_started_script
    #                    - button.press: start_extinguishing_virtual_button



    - interval: 10s
      id: heating_pump_controller
      then:
        - if: 
            condition:
              - lambda: 'return id(water_temp_heating_pump_to_be_fully_on).state - id(stove_water_temp).state <= 10;'
              - lambda: 'return id(water_temp_heating_pump_to_be_fully_on).state - id(stove_water_temp).state >= 0;'
              - binary_sensor.is_on: boot_completed
               #i have to learn this lambda: lambda |- condition for future use
              #- lambda: !lambda |-   
            then:
              - number.set:
                  id: heating_pump_pwm_set_output_percent
                  value: !lambda |
                    float watertemp = id(stove_water_temp).state;
                    float temppumpfullyon = id(water_temp_heating_pump_to_be_fully_on).state;
                    float waterdelta = temppumpfullyon - watertemp;
                    float formula = round(1.0221 * pow(waterdelta, 2) - 20.1727 * waterdelta + 99.9309);
                     // the range of 10 had to be hardcoded for this exponential formula to work. for other range value,
                     // you need to find its corresponding polynomial regression formula
                    return formula;
            else:
              - if:
                  condition:
                   - lambda: 'return id(water_temp_heating_pump_to_be_fully_on).state - id(stove_water_temp).state > 10;'
                   - binary_sensor.is_on: boot_completed
                  then:
                   - number.set:
                        id: heating_pump_pwm_set_output_percent
                        value: 0
                  else:
                    if:
                      condition:
                        - lambda: 'return id(water_temp_heating_pump_to_be_fully_on).state - id(stove_water_temp).state < 0;'
                        - binary_sensor.is_on: boot_completed
                      then:
                         - number.set:
                              id: heating_pump_pwm_set_output_percent
                              value: 100
                      
                 
                 
     


    #AUGER 
    - interval: 10s
      id: auger_dozer_interval
      then:
        - if:
            condition:
                - switch.is_on: ignition_auger_enabler
            then:
                - switch.turn_on: auger_switch
                - delay: !lambda "return id(auger_percent_on_ignition).state * 100;"
                - switch.turn_off: auger_switch
        - if:
            condition:
                - switch.is_on: stabilization_auger_enabler
            then:
                - switch.turn_on: auger_switch
                - delay: !lambda "return id(auger_percent_on_stabilization).state * 100;"
                - switch.turn_off: auger_switch
        - if:
            condition:
                - switch.is_on: normal_run_auger_enabler
            then:
                - switch.turn_on: auger_switch
                - if:
                    condition:
                       - lambda: 'return id(stove_water_temp).state > id(water_temp_heating_pump_to_be_fully_on).state;'
                    then:
                        - delay: !lambda |
                                 float watertemp = id(stove_water_temp).state;
                                 float temppumpfullyon = id(water_temp_heating_pump_to_be_fully_on).state;
                                 float waterdelta = watertemp - temppumpfullyon;
                                 float formula = round((-0.2089 * pow(waterdelta, 2)) - (0.882  * waterdelta) + 44.942);
                                 if (formula >= 45) {
                                  return 4500;
                                 } 
                                 if (formula<=15) {
                                   return 1500;
                                 } 
                                 else { 
                                   return (formula*100);
                                 }
                        - sensor.template.publish:
                            id: auger_modulation_status
                            state: !lambda |
                                  float watertemp = id(stove_water_temp).state;
                                  float temppumpfullyon = id(water_temp_heating_pump_to_be_fully_on).state;
                                  float waterdelta = watertemp - temppumpfullyon;
                                  float formula = round((-0.2089 * pow(waterdelta, 2)) - (0.882  * waterdelta) + 44.942);
                                  if (formula >= 45) {
                                   return 45;
                                  } 
                                  if (formula<=15) {
                                    return 15;
                                  } 
                                  else { 
                                    return (formula);
                                  }
                    else:
                       - delay: !lambda "return id(auger_percent_on_normal_run).state * 100;"
                       - sensor.template.publish:
                            id: auger_modulation_status
                            state: "nan"
                - switch.turn_off: auger_switch
        
    #FAN   #unstable, todo sigma delta for flame unfeed at dangerous temps.
#   - interval: 0.25s
#     id: exhaust_fan_duty
#     then:
#        if:
#          condition:
#            - switch.is_on: exhaust_fan_switch_modulated
#          then:
#              - switch.turn_on: exhaust_fan_switch
#              - delay: 0.124s
#              - switch.turn_off: exhaust_fan_switch

      


#      then:
#        if:
#          condition:
#            - switch.is_on: exhaust_fan_switch_modulated
#          then:max_ambient_temp
#              - switch.turn_on: exhaust_fan_switch
#              - delay: !lambda "return id(fan_percent).state;"
#              - switch.turn_off: exhaust_fan_switch

script:
  - id: air_pressure_binary_sensor_checkup
    mode: restart
    then:
      # off:
      - switch.turn_off: exhaust_fan_switch
      - text_sensor.template.publish:
                      id: air_sensor_checking_ups
                      state: "exhast fan turned off for checking..."
     # - lambda: id(air_pressure_binary_sensor).publish_state(false); # dummy pass
      - wait_until:
          condition:
            - binary_sensor.is_off: air_pressure_binary_sensor 
            - text_sensor.state:
                id: air_sensor_checking_ups
                state: 'exhast fan turned off for checking...'
          timeout: 10s
      - if:
          condition:
            - binary_sensor.is_off: air_pressure_binary_sensor 
            - text_sensor.state:
                id: air_sensor_checking_ups
                state: 'exhast fan turned off for checking...'
          then:
            - switch.turn_on: exhaust_fan_switch
            - text_sensor.template.publish:
                      id: air_sensor_checking_ups
                      state: "exhast fan turned on for checking..."
          else:
            - text_sensor.template.publish:
                      id: stove_status
                      state: "Air pressure sensor failure at stage 1"
            - text_sensor.template.publish:
                      id: air_sensor_checking_ups
                      state: "Air pressure sensor not off at fan stop"
            - script.stop: air_pressure_binary_sensor_checkup                  
      
      #on:
      #- lambda: id(air_pressure_binary_sensor).publish_state(true); #dummy pass
      - wait_until:
          condition:
            - binary_sensor.is_on: air_pressure_binary_sensor
            - text_sensor.state:
                id: air_sensor_checking_ups
                state: 'exhast fan turned on for checking...'
          timeout: 7s
      - if:
          condition:
            - binary_sensor.is_on: air_pressure_binary_sensor
            - text_sensor.state:
                id: air_sensor_checking_ups
                state: 'exhast fan turned on for checking...'
          then:
            - text_sensor.template.publish:
                      id: air_sensor_checking_ups
                      state: "Air pressure sensor responded at fan startup, continuing..."
          else:
            - text_sensor.template.publish:
                      id: stove_status
                      state: "Air pressure sensor failure at stage 2"
            - script.stop: air_pressure_binary_sensor_checkup
      - switch.turn_off: exhaust_fan_switch
      
      #off again:
     # - lambda: id(air_pressure_binary_sensor).publish_state(false); # dummy pass
      - wait_until:
          condition:
            - text_sensor.state:
                id: air_sensor_checking_ups
                state: 'Air pressure sensor responded at fan startup, continuing...'
            - binary_sensor.is_off: air_pressure_binary_sensor
          timeout: 10s
      - if:
          condition:
            - text_sensor.state:
                id: air_sensor_checking_ups
                state: 'Air pressure sensor responded at fan startup, continuing...'
            - binary_sensor.is_off: air_pressure_binary_sensor
          then:
            - text_sensor.template.publish:
                      id: air_sensor_checking_ups
                      state: "Air pressure sensor checked"
          else:
            - text_sensor.template.publish:
                      id: stove_status
                      state: "Air pressure sensor failure at stage 3"
                      
      - script.stop: air_pressure_binary_sensor_checkup

  - id: air_pressure_binary_sensor_checkup_old
    mode: restart
    then:
      - switch.turn_off: exhaust_fan_switch
      - text_sensor.template.publish:
                      id: air_sensor_checking_ups
                      state: "exhast fan turned off for checking..."
      - delay: 10s
      - if:
          condition:
            - binary_sensor.is_off: air_pressure_binary_sensor 
            - text_sensor.state:
                id: air_sensor_checking_ups
                state: 'exhast fan turned off for checking...'
          then:
            - switch.turn_on: exhaust_fan_switch
            - text_sensor.template.publish:
                      id: air_sensor_checking_ups
                      state: "exhast fan turned on for checking..."
          else:
            - text_sensor.template.publish:
                      id: stove_status
                      state: "Air pressure sensor failure at stage 1"
            - text_sensor.template.publish:
                      id: air_sensor_checking_ups
                      state: "Air pressure sensor not off at fan stop"
            - script.stop: air_pressure_binary_sensor_checkup                  

      - delay: 7s
      - if:
          condition:
            - binary_sensor.is_on: air_pressure_binary_sensor
            - text_sensor.state:
                id: air_sensor_checking_ups
                state: 'exhast fan turned on for checking...'
          then:
            - text_sensor.template.publish:
                      id: air_sensor_checking_ups
                      state: "Air pressure sensor responded at fan startup, continuing..."
          else:
            - text_sensor.template.publish:
                      id: stove_status
                      state: "Air pressure sensor failure at stage 2"
            - script.stop: air_pressure_binary_sensor_checkup

      - switch.turn_off: exhaust_fan_switch
      - delay: 10s
      - if:
          condition:
            - text_sensor.state:
                id: air_sensor_checking_ups
                state: 'Air pressure sensor responded at fan startup, continuing...'
            - binary_sensor.is_off: air_pressure_binary_sensor
          then:
            - text_sensor.template.publish:
                      id: air_sensor_checking_ups
                      state: "Air pressure sensor checked"
          else:
            - text_sensor.template.publish:
                      id: stove_status
                      state: "Air pressure sensor failure at stage 3"
                      
      - script.stop: air_pressure_binary_sensor_checkup



  - id: ignition_script
    mode: single
    then:
      - text_sensor.template.publish:
                      id: air_sensor_checking_ups
                      state: ""
      - text_sensor.template.publish:
                            id: exhaust_fan_status
                            state: ""
      - text_sensor.template.publish:
                      id: stove_status
                      state: "Ingnition precheck.." 
      - script.execute: air_pressure_binary_sensor_checkup
      - wait_until:
                condition:
                  not:
                    - script.is_running: air_pressure_binary_sensor_checkup
                timeout: 1min
      - if:
          condition:
            - text_sensor.state:
                id: air_sensor_checking_ups
                state: 'Air pressure sensor checked'
          then:
            - text_sensor.template.publish:
                      id: air_sensor_checking_ups
                      state: "Checked by ignition"
            - text_sensor.template.publish:
                      id: stove_status
                      state: "Ingnition"                   
            - switch.turn_on: exhaust_fan_switch
            - switch.turn_on: igniter_switch
            #todo remeber after reboot igniting switch
            - switch.turn_off: extinguish_completed
            - number.set:
                  id: stove_exhaust_temp_before_ignition
                  value: !lambda "return id(exhaust_temp).state;"
            - if:
                condition:
                    - switch.is_off: prefilled
                then:
                    - switch.turn_on: auger_switch 
                    - text_sensor.template.publish:
                                    id: auger_status
                                    state: "Prefilling..."                
                    - delay: ${auger_prefill_time}
                    # publish here
                    - switch.turn_off: auger_switch
                    - switch.turn_on: prefilled
                else:
                    - text_sensor.template.publish:
                                    id: auger_status
                                    state: "Skipped prefilling..."
            - switch.turn_on: ignition_auger_enabler
            - text_sensor.template.publish:
                      id: auger_status
                      state: "Dosing for ignition"
            - script.execute: ignition_auger_timeout_stopper_script
            #- number.set:
            #      id: exhaust_temp # dummy pass, 101 will bypass stabilisation as well
            #      value: 101

            - wait_until:
                condition:
                   - lambda: 'return id(exhaust_temp).state > id(stove_exhaust_temp_before_ignition).state + ${ignition_delta_to_confirmed};'
                timeout: ${wait_for_ignition_time}
            - if:
                condition:
                  - lambda: 'return id(exhaust_temp).state > id(stove_exhaust_temp_before_ignition).state + ${ignition_delta_to_confirmed};'
                then:
                  - text_sensor.template.publish:
                            id: stove_status
                            state: "Ignition successful"
                  - switch.turn_off: auger_switch
                  - switch.turn_off: igniter_switch
                  - switch.turn_off: ignition_auger_enabler
                  - if: 
                        condition:
                           - not:
                              - script.is_running: normal_extinguish_script
                        then:
                          - script.execute: stabilization_script
                          - script.stop: ignition_script
                        else:
                          - text_sensor.template.publish:
                              id: stove_status
                              state: "Extinguishing script prevented switching to stabilization"
                          - script.stop: ignition_script

                else:
                  - text_sensor.template.publish:
                            id: auger_status
                            state: "Stopped by failed ignition" 
                  - switch.turn_off: auger_switch
                  - switch.turn_off: igniter_switch
                  - switch.turn_off: ignition_auger_enabler
                  - script.execute: normal_extinguish_script
                  - script.stop: ignition_auger_timeout_stopper_script
                  - delay: 1s #insert text while executing above script
                  - text_sensor.template.publish:
                            id: stove_status
                            state: "Failed ignition, extinguishing..."  
                  - script.wait: normal_extinguish_script
                  - delay: 1s
                  - text_sensor.template.publish:
                            id: stove_status
                            state: "Failed Ignition"
                  - script.stop: ignition_script
                      
  - id: ignition_auger_timeout_stopper_script
    mode: single
    then:
      - delay: ${wait_for_preignition_time}
      - if:
         condition:
            - lambda: 'return id(exhaust_temp).state < id(stove_exhaust_temp_before_ignition).state + (${ignition_delta_to_confirmed}/4);' #todo better exaust sensor noise filtering?
         then:
            - text_sensor.template.publish:
                            id: auger_status
                            state: "Paused dosing for ignition, waiting for temp increase.." 
            - switch.turn_off: ignition_auger_enabler
            - wait_until:
                condition:
                   - lambda: 'return id(exhaust_temp).state > id(stove_exhaust_temp_before_ignition).state + (${ignition_delta_to_confirmed}/4);'
                # no timeout
            - switch.turn_on: ignition_auger_enabler
            - text_sensor.template.publish:
                            id: auger_status
                            state: "Resumed dosing for ignition" 
            - script.stop: ignition_auger_timeout_stopper_script
                


  - id: normal_extinguish_script     #todo dinamic timing depending on memorised temp
    mode: restart
    then:
      - switch.turn_on: exhaust_fan_switch
      - switch.turn_off: extinguish_completed
      #- switch.turn_off: ignition_auger_enabler
      - switch.turn_off: stabilization_auger_enabler
      - switch.turn_off: normal_run_auger_enabler
      - switch.turn_off: auger_switch
      #- switch.turn_off: heating_pump_slow_pwm_enabler
      - script.stop: air_pressure_binary_sensor_checkup
      - text_sensor.template.publish:
                            id: stove_status
                            state: "Extinguishing"  

      - text_sensor.template.publish:               
                            id: exhaust_fan_status
                            state: ""  
      - text_sensor.template.publish:             
                            id: auger_status
                            state: ""                    
      - if:
          condition:
            - script.is_running: ignition_script 
          then:
            - text_sensor.template.publish:
                            id: exhaust_fan_status
                            state: "Waiting for ignition and then will extinguish" 
            - script.wait: ignition_script #has its owm timeout
            
      - if:
          condition:
              - lambda: 'return id(exhaust_temp).state < ${extinguished_temp};'
          then:
              - text_sensor.template.publish:
                            id: exhaust_fan_status
                            state: "Extinguishing, already cold enough, will stop in ${minimum_extinguish_time}..."
              - delay: ${minimum_extinguish_time}
              - switch.turn_off: exhaust_fan_switch
              - text_sensor.template.publish:
                            id: exhaust_fan_status
                            state: "Was cold, stopped by timeout only."
          else:
              # fan modulation for safety here
              - if:
                  condition:
                     or:
                       - lambda: 'return id(exhaust_temp).state > ${exhaust_absolute_max_temp};'
                       - lambda: 'return id(stove_water_temp).state > ${max_water_temp};'
                  then:
                    - text_sensor.template.publish:
                            id: exhaust_fan_status
                            state: "Modulated for safety"
                    - text_sensor.template.publish:
                            id: stove_status
                            state: "Safety"
                    - switch.turn_on: fan_sigma_delta_enabler
                    - number.set:
                            id: fan_sigma_delta_modulation
                            value: ${fan_percent_on_safety}
                    - switch.turn_on: fan_sigma_delta_enabler
                    - rtttl.play: long:d=1,o=5,b=100:e6
                    - rtttl.play: long:d=1,o=5,b=100:e6
                    - wait_until:
                          condition:
                            not:
                              - lambda: 'return id(exhaust_temp).state > (${exhaust_absolute_max_temp} - 50);'
                              - lambda: 'return id(stove_water_temp).state > (${max_water_temp} - 10);'
                          #no timeout
                    - switch.turn_off: fan_sigma_delta_enabler
                    - switch.turn_on: exhaust_fan_switch

              - text_sensor.template.publish:
                            id: exhaust_fan_status
                            state: "Extinguishing, waiting for temp to be lower than ${extinguished_temp}..."
              - wait_until:
                  condition:
                     - lambda: 'return id(exhaust_temp).state < ${extinguished_temp};' 
              - text_sensor.template.publish:
                            id: exhaust_fan_status
                            state: "Extinguishing, stopping by timeout, was hot when started..."
              - delay: ${minimum_extinguish_time}
              - if:
                  condition:
                   - binary_sensor.is_off: boot_completed
                  then:
                    - switch.turn_off: prefilled

              - switch.turn_off: exhaust_fan_switch
              - text_sensor.template.publish:
                            id: exhaust_fan_status
                            state: "Extinguished, was hot when started."
      - switch.turn_on: extinguish_completed
      - if:
          condition:
            - binary_sensor.is_on: boot_completed
          then:
            - text_sensor.template.publish:
                            id: stove_status
                            state: "Ready for ignition" 
          else:
            - text_sensor.template.publish:
                            id: stove_status
                            state: "Extinguished" 
                            #ready for ignition?  Extinguished?
      - script.stop: normal_extinguish_script
              
  - id: stabilization_script
    mode: single
    then:
      - switch.turn_on: stabilization_auger_enabler

      - text_sensor.template.publish:
                            id: stove_status
                            state: ""
      - text_sensor.template.publish:
                            id: exhaust_fan_status
                            state: ""
      - text_sensor.template.publish:
                            id: auger_status
                            state: ""
      
      - text_sensor.template.publish:
                            id: exhaust_fan_status
                            state: "Switched to stabilization"
      - text_sensor.template.publish:
                            id: auger_status
                            state: "Dosing for stabilization"
    #  - if:
    #      condition:
    #        - lambda: 'return id(exhaust_temp).state < 90;'
    #      then:
    #        - switch.turn_on: igniter_switch
      - text_sensor.template.publish:
                            id: stove_status
                            state: "Stabilizing"

      - wait_until:
                  condition:
                    for:
                      time: ${minimum_run_of_stabilization_time}
                      condition:
                        - lambda: 'return id(exhaust_temp).state > ${fully_ignited_temp};'
                  timeout: ${maximum_wait_for_stabilization_time}

      - if:
          condition:
            - lambda: 'return id(exhaust_temp).state > ${fully_ignited_temp};'
          then:
            - text_sensor.template.publish:
                            id: stove_status
                            state: "Stabilized" 
            - delay: 1s      #just to show above message in the ha history     
            - if: 
                condition:
                   - not:
                      - script.is_running: normal_extinguish_script
                then:
                    - switch.turn_off: stabilization_auger_enabler
                    - script.execute: normal_run_script
                    - delay: 1s
                    - script.stop: stabilization_script
          else:
            - switch.turn_off: auger_switch
            - switch.turn_off: stabilization_auger_enabler
            - switch.turn_off: igniter_switch
            - script.execute: normal_extinguish_script
            - delay: 1s #insert text while executing above script
            - text_sensor.template.publish:
                      id: stove_status
                      state: "Failed stabilization, extinguishing..."  
            - script.wait: normal_extinguish_script
            - delay: 1s
            - text_sensor.template.publish:
                      id: stove_status
                      state: "Failed Stabilization"
            - script.stop: stabilization_script

  - id: normal_run_script
    mode: single
    then:
      - script.execute: monitoring_unexpected_script_for_normal_operation
      - switch.turn_on: normal_run_auger_enabler
      - switch.turn_off: prefilled
      - text_sensor.template.publish:
                            id: stove_status
                            state: ""
      - text_sensor.template.publish:
                            id: exhaust_fan_status
                            state: ""
      - text_sensor.template.publish:
                            id: auger_status
                            state: ""
      - delay: 5s
      #- number.set:
      #            id: stove_water_temp # dummy pass
      #            value: 69

      - text_sensor.template.publish:
                            id: stove_status
                            state: "Normal"
      - text_sensor.template.publish:
                            id: exhaust_fan_status
                            state: "Normal"
      - text_sensor.template.publish:
                            id: auger_status
                            state: "Dosing for normal running operation"
      - script.wait: monitoring_unexpected_script_for_normal_operation
      - script.stop: normal_run_script
         
    
  - id: booting_script
    mode: single
    then:
      - switch.turn_on: heating_pump_switch
      - switch.turn_on: exhaust_fan_switch ##just in case it failed turning on at that very early boot
      - output.turn_on: TM1638Led8
      - text_sensor.template.publish:
                                        id: stove_status
                                        state: "Booting checkup..."
      - text_sensor.template.publish:
                            id: heating_pump_status
                            state: "ON by booting script"
      - text_sensor.template.publish:
                            id: exhaust_fan_status
                            state: "ON by booting script, waiting for not nan"
      - wait_until:
          condition:
              - binary_sensor.is_off: is_nan_exhaust_temp
          timeout: 60s

      - if: 
          condition:
            - binary_sensor.is_on: is_nan_exhaust_temp #needs booting at later stages to work properly
          then: 
            - text_sensor.template.publish:
                            id: exhaust_fan_status
                            state: "Timeout exeeded at waiting for not nan"
            - text_sensor.template.publish:
                            id: stove_status
                            state: "Error, check exhaust temp sensor"
            - lambda: id(boot_completed).publish_state(false);
            - switch.turn_on: heating_pump_switch
            - script.stop: booting_script
      
      - if: 
          condition:
            or:
             - switch.is_off: extinguish_completed
             - lambda: 'return id(exhaust_temp).state > ${extinguished_temp};'
          then: 
            - script.execute: normal_extinguish_script
            - text_sensor.template.publish:
                      id: stove_status
                      state: "Waiting water temp to get lower than ${min_ignition_water_temp} (at boot)" 
            - wait_until:
                  condition:
                      - lambda: 'return id(stove_water_temp).state < ${min_ignition_water_temp};'

            - switch.turn_off: heating_pump_switch
            - text_sensor.template.publish:
                            id: heating_pump_status
                            state: "OFF by booting script"
            - text_sensor.template.publish:
                      id: stove_status
                      state: "Waiting for extinguishing (at boot)"
            - script.wait: normal_extinguish_script
          else:
            - text_sensor.template.publish:
                            id: exhaust_fan_status
                            state: "OFF by booting script"

      - text_sensor.template.publish:
                id: air_sensor_checking_ups
                state: ""
      - text_sensor.template.publish:
                      id: stove_status
                      state: "Binary air sensor check (at boot)"
      - script.execute: air_pressure_binary_sensor_checkup
      - script.wait: air_pressure_binary_sensor_checkup
      - if:
          condition:
            - not:
               - text_sensor.state:
                    id: air_sensor_checking_ups
                    state: 'Air pressure sensor checked'
          then:
            - text_sensor.template.publish:
                      id: stove_status
                      state: "Error, check air pressure sensor (at boot)"
            - lambda: id(boot_completed).publish_state(false);
            - switch.turn_on: heating_pump_switch
            - script.stop: booting_script
          else:
            - text_sensor.template.publish:
                            id: air_sensor_checking_ups
                            state: "Checked at boot"
            - if:
                condition:
                  - lambda: 'return id(water_pressure).state > ${min_water_pressure};'
                  - lambda: 'return id(water_pressure).state < ${max_water_pressure};'
                then:
                  - lambda: id(boot_completed).publish_state(true);
                  - text_sensor.template.publish:
                                  id: stove_status
                                  state: "Ready for ignition"
                  - lambda: id(water_pressure_good).publish_state(true);
                else:
                  - text_sensor.template.publish:
                                  id: stove_status
                                  state: "Water pressure problem (boot checkup)"
                  - lambda: id(water_pressure_good).publish_state(false);
                  - lambda: id(boot_completed).publish_state(false);
            - script.stop: booting_script


  - id: monitoring_unexpected_script_for_normal_operation
    mode: restart
    then:
      - wait_until:
            condition:
              or:
                - lambda: 'return id(exhaust_temp).state > ${exhaust_absolute_max_temp};'
                - lambda: 'return id(exhaust_temp).state < ${fully_ignited_temp}*0.75;'
                - text_sensor.state:
                          id: stove_status
                          state: 'Extinguishing'

      - switch.turn_off: normal_run_auger_enabler
      - switch.turn_off: ignition_auger_enabler
      - switch.turn_off: stabilization_auger_enabler
      - text_sensor.template.publish:
                                  id: stove_status
                                  state: "Error by normal run monitoring script"
      - rtttl.play: 'two_short:d=4,o=5,b=100:16e6,16e6'
      - text_sensor.template.publish:
                                  id: auger_status
                                  state: "Stopped by normal run monitoring script"
      - lambda: id(boot_completed).publish_state(false);
      - if:
          condition:
            - lambda: 'return id(exhaust_temp).state > ${exhaust_absolute_max_temp};'
          then:
            - text_sensor.template.publish:
                            id: unexpected
                            state: "Exhaust > ${exhaust_absolute_max_temp}"
      - if:
          condition:
            - lambda: 'return id(exhaust_temp).state < ${fully_ignited_temp}*0.75;'
          then:
            - text_sensor.template.publish:
                            id: unexpected
                            state: "Exhaust temp < ${fully_ignited_temp}*0.75" 

                                      
      - script.stop: normal_run_script
      - script.stop: ignition_script
      - script.stop: stabilization_script
      - script.execute: normal_extinguish_script     #will restart  

climate:
  - platform: bang_bang
    name: "Climate Controller"
    id: climate_controller
    sensor: ambient_temp
    default_target_temperature_low: 15
    default_target_temperature_high: 17
    away_config:
        default_target_temperature_low: ${min_ambient_temp}
        default_target_temperature_high: ${max_ambient_temp}
    visual:
      min_temperature: 3
      max_temperature: 26
      temperature_step: 0.1
    heat_action:
      - script.wait: booting_script
      - if:
            condition:
                - binary_sensor.is_on: boot_completed
                - text_sensor.state:
                          id: stove_status
                          state: 'Ready for ignition'

            then:
                - homeassistant.service:
                    service: notify.samuel
                    data:
                      title: Porneste!
                    data_template:
                      message: "{{my_variable|round(1)}}°C, a pornit centrala singura!"
                    variables:
                         my_variable: |-
                            return id(ambient_temp).state;
                - button.press: start_ignition_virtual_button
            else:
              - climate.control:
                    id: climate_controller
                    mode: "OFF"
              - rtttl.play: 'scale_inverted:d=32,o=5,b=100:b,a#,g#,f#,e,d#,c,c#'

    idle_action:
      - if:
          condition:
           not:
            - text_sensor.state:
                          id: stove_status
                          state: 'Ready for ignition'
          then:
            - homeassistant.service:
                service: notify.samuel
                data:
                  title: Se opreste!
                data_template:
                  message: "{{my_variable|round(1)}}°C, s-a oprit centrala!"
                variables:
                     my_variable: |-
                        return id(ambient_temp).state;
            - button.press: start_extinguishing_virtual_button
